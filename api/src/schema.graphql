type Kanji {
  id: ID!
  value: String
  readings: [Reading] @relation(name: "HAS_READING", direction: "OUT")
  meanings: [Meaning] @relation(name: "HAS_MEANING", direction: "OUT")

  notMeanings: [Meaning]
    @cypher(
      statement: """
        MATCH (this)-[:SIMILAR]-(k2:Kanji)-[:HAS_MEANING]->(m2:Meaning)
        WHERE NOT (this)-[:HAS_MEANING]->(m2)
        WITH DISTINCT m2 AS meaning, rand() AS rand
        RETURN meaning
        ORDER BY rand
      """
    )
}

type Reading {
  id: ID!
  value: String
}

type Meaning {
  id: ID!
  value: String
}

type User {
  id: ID!
  name: String!
}


type Query {
  randomKanji(level: String): Kanji
    @cypher(
      statement: """
        MATCH (k:Kanji)-[:HAS_LEVEL]->(:Level {value: $level})
        WITH k, rand() AS rand
        RETURN k
        ORDER BY rand
        LIMIT 1
      """
    )
}
